"""
astromatch module for cross-matching astronomical catalogues
using the Nway python package. Nway by Johannes Buchnner.

Reference: Salvato et al. 2018.

@author: A.Ruiz
"""
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from six.moves import range
from io import open

import os
import warnings
from inspect import signature

from numpy import isfinite

try:
    # python 3
    from contextlib import redirect_stdout
except:
    # python 2
    from contextlib2 import redirect_stdout

try:
    # python 3
    FileNotFoundError
except NameError:
    # python 2
    FileNotFoundError = IOError

from astropy import units as u
from astropy.table import Table, Column, join
from nwaylib import nway_match

from .priors import Prior
from .match import BaseMatch


class NWMatch(BaseMatch):
    """
    Class for crossmatching catalogues using Nway.
    """

    _cutoff_column = "prob_has_match"

    ### Public Methods
    def run(
        self,
        radius=6 * u.arcsec,
        use_mags=False,
        dist_post_min=0.9,
        **kwargs
    ):
        """
        Perform the cross-matching between the defined catalogues.

        Parameters
        ----------
        radius : ``Quantity``, optional
            Maximum search radius for counterparts. It must be an angular
            ``Quantity``. Defaults to 6 arcsec.
        use_mags : ``boolean``, optional
            apply corrections to the association probabilities based on the
            magnitudes of the counterpart sources. To this end, probability
            priors are constructed for each magnitude contained in the
            secondary catalogues.
        priors : dictionary of ``Prior`` objects or `None`, optional
            Dictionary of Prior objects to be used in the cross-match. It has to
            be defined consistently with the magnitudes of the secondary catalogues.
            If `None`, the method set by `dist_post_min` is used to build the priors.
            Defaults to `None`.
        dist_post_min : ``float`` or ``None``, optional
            If not ``None``, the nway library selects associations with position-based
            probability above this value to calculate the magnitude probability priors. 
            If not ``None``, they are estimated using ``Prior`` objects.
            See the ``Prior`` documentation for details on how these are calculated.
            Defaults to 0.9.
        mag_include_radius : ``Quantity``, optional
            Search radius around sources in the primary catalogue for
            building the magnitude priors. It must be an angular ``Quantity``.
            Defaults to 6 arcsec.
        prob_ratio_secondary : `float`, optional
            Minimum value of the probability ratio between two counterparts
            for the same primary source to be flagged as a secondary match.

        Other Parameters
        ----------------
        **kwargs : ``Prior`` and nway_match parameters.
            See the corresponding documentation for details.
        """
        self.radius = radius
        kwargs_prior, kwargs_run = self.parse_args(kwargs)

        nwaycats_list, priors_dict = self._get_nwaycats(
            use_mags, dist_post_min, **kwargs_prior
        )

        # We need to store the magnitude histogram files generated by nway
        # when bayes_prior is used, in order to create a proper prior.
        if use_mags and not priors_dict:
            store_mag_hists = True
        else:
            store_mag_hists = False

        match = self._nway_match(
            nwaycats_list, store_mag_hists, dist_post_min, **kwargs_run
        )

        if use_mags:
            # define _priors attribute
            if not priors_dict:
                self._priors = self._prior_from_nway_hist_files(match, dist_post_min)
            else:
                self._priors = priors_dict

        self._remove_mag_hist_files()

        return match

    ### Internal Methods
    def _get_nwaycats(self, use_mags, dist_post_min, **kwargs):
        priors_dict = {}
        priors = kwargs.pop("priors", None)

        nwaycats_list = [self.pcat.nway_dict()]
        for cat in self.scats:
            nwaycat = cat.nway_dict(use_mags=use_mags)

            if use_mags:
                if priors is not None:
                    prior = priors[cat.name]
                    nwaycat["maghists"] = prior.to_nway_hists()
                    priors_dict[cat.name] = prior

                else:
                    if not dist_post_min:
                        prior = Prior(self.pcat, cat, **kwargs)
                        nwaycat["maghists"] = prior.to_nway_hists()
                        priors_dict[cat.name] = prior

            nwaycats_list.append(nwaycat)

        return nwaycats_list, priors_dict

    def _nway_match(self, nwaycats_list, store_mag_hists, dist_post_min, **kwargs):
        kwargs = self._parse_nway_match_args(kwargs)
        match_radius = self.radius.to(u.arcsec).value

        with warnings.catch_warnings():
            warnings.filterwarnings("ignore", category=RuntimeWarning)

            match = nway_match(
                nwaycats_list,
                match_radius=match_radius,
                store_mag_hists=store_mag_hists,
                magauto_post_single_minvalue=dist_post_min,
                **kwargs
            )

        # match = self._add_total_bayes_factor(match)
        match = self._add_srcids(match)

        pcat_idcol = "SRCID_{}".format(self.pcat.name)
        match = self._sort_as_pcat(match, pcat_idcol)

        return match

    def _add_total_bayes_factor(self, match):
        match = Table.from_pandas(match)

        total_bf = match["dist_bayesfactor"]
        for cat in self.scats:
            for mag in cat.mags.colnames:
                try:
                    bias_col = "bias_{}_{}".format(cat.name, mag)
                    total_bf += match[bias_col]
                except KeyError:
                    continue

        total_bf_col = Column(name="total_bayesfactor", data=total_bf)
        match.add_column(total_bf_col, index=match.index_column("p_single"))

        return match

    def _add_srcids(self, match):
        match = Table.from_pandas(match)
        match["IDX"] = range(len(match))

        catalogues = [self.pcat] + list(self.scats)
        for cat in catalogues[::-1]:
            srcids = Table()
            srcids["SRCID_" + cat.name] = cat.ids.data
            srcids[cat.name] = range(len(cat))
            match = join(srcids, match, keys=cat.name, join_type="right")
            match.remove_column(cat.name)

        # Recover original sorting
        match.sort("IDX")
        match.remove_column("IDX")

        return match

    def _prior_renorm_factors(self, cat, secure_match):
        # Astromatch priors for the target sources are normalized to the overall
        # identification ratio. NWAY prior histograms are normalized to unity.
        # If we multiply the NWAY histograms by the the number of secure counterparts
        # found for a given secondary catalogue (i.e. with dist_post above the
        # selection limit chosen to build the prior), and divide by the total number
        # of sources in the primary catalogue, we have an estimation of the
        # overall identification ratio.
        id_col = "SRCID_" + cat.name
        mask_counterparts = ~secure_match[id_col].mask
        ids_counterparts = secure_match[id_col][mask_counterparts]
        secure_counterparts = cat.select_by_id(ids_counterparts)

        renorm_factors = {}
        for mag in cat.mags.colnames:
            # Only sources with good magnitudes were used to build the NWAY histogram
            mask_good = isfinite(secure_counterparts.mags[mag])
            good_counterparts = secure_counterparts[mask_good]

            renorm_factors[mag] = 1.0 * len(good_counterparts) / len(self.pcat)

        return renorm_factors

    def _prior_from_nway_hist_files(self, match, dist_post_min):
        secure_match = match[match["dist_post"] > dist_post_min]

        priors_dict = {}
        for cat in self.scats:
            renorm_factors = self._prior_renorm_factors(cat, secure_match)
            priors_dict[cat.name] = Prior.from_nway_hists(cat, renorm_factors)

        return priors_dict

    def _remove_mag_hist_files(self, path="."):
        for cat in self.scats:
            name = cat.name
            for mag in cat.mags.colnames:
                histfile = os.path.join(path, "{}_{}_fit.txt".format(name, mag))
                plotfile = os.path.join(path, "{}_{}_fit.pdf".format(name, mag))

                try:
                    os.remove(histfile)
                    os.remove(plotfile)
                except (FileNotFoundError, OSError):
                    pass

    def _match_rndcat(self, **kwargs):
        # Cross-match secondary catalogues with a randomized
        # version of the primary catalogue
        xm_rnd = NWMatch(self.pcat.randomise(numrepeat=1), *self.scats)

        if self._priors:
            use_mags = True
        else:
            use_mags = False

        # Hide std ouput of nway_match
        with redirect_stdout(open(os.devnull, "w")):
            # Use same search radius and magnitude priors as the original cross-match
            match_rnd = xm_rnd.run(
                radius=self.radius, use_mags=use_mags, priors=self._priors, **kwargs
            )

        return match_rnd

    def _match_fake(self, candidates, **kwargs):
        # Cross-match a randomized version of the primary catalogue
        # with a secondary catalogue where fake counterparts for the primary
        # have been introduced. This is for calculating statistics using
        # the Broos et al. 2006 method.
        rndpcat = self.pcat.randomise(numrepeat=1)

        # Create a set of fake counterparts for the primary catalogue
        fakes = rndpcat.set_fake_counterparts(candidates)

        # Remove candidates from the secondary catalogue
        # We assume that there is only one secondary catalogue!!!
        scat_nocandidates = self.scats[0].remove_by_id(candidates.ids)

        # Set as secondary catalogue the union of the candidates-removed
        # secondary catalogue with the catalogue of fake counterparts
        scat_withfakes = scat_nocandidates.join(fakes)

        xm_rnd = NWMatch(rndpcat, scat_withfakes)

        if self._priors:
            use_mags = True
        else:
            use_mags = False

        # Hide std ouput of nway_match
        with redirect_stdout(open(os.devnull, "w")):
            # Use same search radius and magnitude priors as the original cross-match
            match_rnd = xm_rnd.run(
                radius=self.radius, use_mags=use_mags, priors=self._priors, **kwargs
            )

        return match_rnd

    @staticmethod
    def _reliability(data):
        return data["prob_has_match"] * data["prob_this_match"]

    @staticmethod
    def _parse_nway_match_args(kwargs):
        sig = signature(nway_match)
        kwargs_default = [p for p in sig.parameters]

        kwargs_nway = {}
        for key, value in kwargs.items():
            if key in kwargs_default:
                kwargs_nway[key] = value

        return kwargs_nway
